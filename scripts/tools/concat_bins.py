#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Build one Experience per bin from bin_*.txt lists generated by split_by_end_s.py.
Each bin list contains lines: <path>\t<end_s>.
We derive item IDs from filenames like <id>_activity.json and generate a temp item.yaml
that lists these items for the 'ego4d' dataset. Then we call EgoCL Concatenator to
assemble an Experience and save it to outputs.

Usage:
  python scripts/tools/concat_bins.py \
    --bins-dir outputs/ego4d/splits_end_s \
    --out-dir outputs/ego4d/experiences \
    --style sequential
"""
from __future__ import annotations
import os, re, glob, tempfile, json, argparse
from typing import List


def extract_id_from_path(p: str) -> str | None:
    # Expect filenames like <id>_activity.json
    base = os.path.basename(p)
    m = re.match(r"([0-9a-fA-F\-]+)_activity\.json$", base)
    if m:
        return m.group(1)
    return None


def write_item_yaml(ids: List[str], out_path: str):
    import yaml
    data = {
        'base': {
            'log_level': 'INFO',
            'items': [],
            'item_file': '',
            'num': -1,
        },
        'datasets': {
            'ego4d': {
                'items': ids,
                'item_file': ''
            }
        }
    }
    with open(out_path, 'w', encoding='utf-8') as f:
        yaml.safe_dump(data, f, sort_keys=False, allow_unicode=True)


def build_experience(item_yaml: str, style: str = 'sequential'):
    """Try to build via EgoCL.Concatenator; if unavailable (e.g., cv2 import), fallback to JSON-only concat.

    Returns an object with .save(out_path) and .duration and .activities compatible enough for our prints.
    """
    try:
        # Ensure project root on sys.path
        import sys, os as _os
        repo_root = _os.path.abspath(_os.path.join(_os.path.dirname(__file__), '..', '..'))
        if repo_root not in sys.path:
            sys.path.insert(0, repo_root)

        from EgoCL import Concatenator
        C = Concatenator(style=style)
        cfg_obj = type('Cfg', (), {'item_config': item_yaml})()
        E = C(cfg_obj)
        return E
    except Exception as e:
        # Fallback: build experience by reading item_yaml, loading activity JSONs directly, and composing timeline
        import yaml, json
        with open(item_yaml, 'r', encoding='utf-8') as f:
            cfg = yaml.safe_load(f)
        ids = []
        for ds, dscfg in (cfg.get('datasets') or {}).items():
            if isinstance(dscfg, dict) and isinstance(dscfg.get('items'), list):
                ids.extend(dscfg['items'])
        # infer unified root for ego4d consistent with EgoCL.data.UNI_PATHS_GLOBAL default
        uni_root = '/home/yl/D/Ego4d'
        activities = []
        for _id in ids:
            p = os.path.join(uni_root, f"{_id}_activity.json")
            try:
                with open(p, 'r', encoding='utf-8') as f:
                    activities.append(json.load(f))
            except Exception:
                continue
        # build timeline sequentially
        time_line = []
        cur = 0.0
        for idx, a in enumerate(activities):
            v = a.get('VIDEO', {}) if isinstance(a.get('VIDEO'), dict) else {}
            try:
                vstart = float(v.get('start_s', 0) or 0)
                vend = float(v.get('end_s', 0) or 0)
                dur = vend - vstart if vend > vstart else float(v.get('duration', 0) or 0)
            except Exception:
                dur = 0.0
            if dur <= 0:
                dur = 5.0
            entry = {'activity_id': idx, 'start_s': cur, 'end_s': cur + dur, 'duration': dur}
            time_line.append(entry)
            cur += dur

        class _Exp:
            def __init__(self, acts, tl, start=0.0):
                self._acts = acts
                self._tl = tl
                self.start_s = start
            def save(self, out_path: str):
                os.makedirs(os.path.dirname(out_path), exist_ok=True)
                data = {
                    'start_s': self.start_s,
                    'duration': self.duration,
                    'activities': self._acts,
                    'time_line': self._tl,
                }
                with open(out_path, 'w', encoding='utf-8') as f:
                    json.dump(data, f, ensure_ascii=False, indent=2)
            @property
            def duration(self):
                if not self._tl:
                    return 0.0
                return float(self._tl[-1]['end_s']) - self.start_s
            @property
            def activities(self):
                class _Acts:
                    def __init__(self, lst): self.activities = lst
                    def __len__(self): return len(self.activities)
                return _Acts(self._acts)

        return _Exp(activities, time_line)


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument('--bins-dir', required=True, help='Directory containing bin_*.txt produced by split_by_end_s.py')
    ap.add_argument('--out-dir', required=True, help='Output directory for Experience JSONs')
    ap.add_argument('--style', default='sequential', choices=['sequential', 'random', 'clip'], help='Concatenation style')
    args = ap.parse_args()

    os.makedirs(args.out_dir, exist_ok=True)

    bin_files = sorted(glob.glob(os.path.join(args.bins_dir, 'bin_*.txt')))
    if not bin_files:
        raise SystemExit(f"No bin_*.txt found under {args.bins_dir}")

    for i, bin_path in enumerate(bin_files, start=1):
        # Read IDs from bin file
        ids = []
        with open(bin_path, 'r', encoding='utf-8') as f:
            for line in f:
                line = line.strip()
                if not line:
                    continue
                path = line.split('\t')[0]
                _id = extract_id_from_path(path)
                if _id:
                    ids.append(_id)
        if not ids:
            print(f"[warn] No IDs extracted from {bin_path}, skipping.")
            continue

        # Create a temp item.yaml
        with tempfile.NamedTemporaryFile('w', suffix='.yaml', delete=False) as tf:
            tmp_yaml = tf.name
        write_item_yaml(ids, tmp_yaml)

        # Build experience
        try:
            E = build_experience(tmp_yaml, style=args.style)
        finally:
            # Clean up temp yaml
            if os.path.exists(tmp_yaml):
                os.unlink(tmp_yaml)

        # Save experience
        out_path = os.path.join(args.out_dir, f'experience_bin_{i}.json')
        E.save(out_path)
        print(f"Saved {out_path} ({len(E.activities)} activities, duration={E.duration:.2f}s)")


if __name__ == '__main__':
    main()
